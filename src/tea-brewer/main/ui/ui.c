// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.4
// LVGL version: 9.2.2
// Project name: SquareLine_Project

#include "ui.h"
#include "ui_helpers.h"
#include "ui_events.h"
#include "iot_knob.h"
#include "../settings.h"
#include "../uart_comm.h"
#include "esp_lvgl_port.h"
#include "esp_log.h"

static const char *TAG_UI = "UI";

///////////////////// VARIABLES ////////////////////

// EVENTS
lv_obj_t * ui____initial_actions0;

// Motor state tracking
static bool motor_waiting_for_home = false;
static int32_t motor_pending_position = -1;

// Tea names array
static const char* tea_names[MAX_TEA_TYPES] = {
    "Green Tea",
    "Black Tea",
    "Herbal Tea",
    "Fruit Tea",
    "White Tea",
    "Functional Tea"
};

// Tea colors (RGB hex values)
const uint32_t tea_colors[MAX_TEA_TYPES] = {
    0x92A202,  // Green Tea
    0xCE9958,  // Black Tea
    0xE7C789,  // Herbal Tea
    0xD76C6C,  // Fruit Tea
    0xC4BCB5,  // White Tea
    0xE9D257   // Functional Tea
};

// Tea background images
static const lv_image_dsc_t* tea_background_images[MAX_TEA_TYPES] = {
    &ui_img_greenteascreen_png,      // Green Tea
    &ui_img_blackteascreen_png,      // Black Tea
    &ui_img_herbalteascreen_png,     // Herbal Tea
    &ui_img_fruitteascreen_png,      // Fruit Tea
    &ui_img_whiteteascreen_png,      // White Tea
    &ui_img_functionalteascreen_png  // Functional Tea
};

// IMAGES AND IMAGE SETS

///////////////////// TEST LVGL SETTINGS ////////////////////
#if LV_COLOR_DEPTH != 16
    #error "LV_COLOR_DEPTH should be 16bit to match SquareLine Studio's settings"
#endif

///////////////////// ANIMATIONS ////////////////////

///////////////////// FUNCTIONS ////////////////////

void LVGL_knob_event(void *event)
{
    knob_event_t knob_event = (knob_event_t)(uintptr_t)event;
    
    // Lock LVGL for thread-safe operation
    lvgl_port_lock(0);
    
    // Only handle knob events on navigable screens
    if (ui_screen_state.current_screen != UI_SCREEN_MAIN &&
        ui_screen_state.current_screen != UI_SCREEN_TEA &&
        ui_screen_state.current_screen != UI_SCREEN_SETTINGS) {
        lvgl_port_unlock();
        return;
    }
    
    if (knob_event == KNOB_RIGHT) {  // Swapped: RIGHT now goes left
        // Right rotation → Navigate LEFT
        if (ui_screen_state.current_screen == UI_SCREEN_MAIN) {
            // MAIN → SETTINGS
            _ui_screen_change(&ui_SettingsScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_SettingsScreen_screen_init);
        }
        else if (ui_screen_state.current_screen == UI_SCREEN_TEA) {
            if (current_tea_index == 0) {
                // TEA[0] → MAIN
                _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_MainScreen_screen_init);
            } else {
                // TEA[n] → TEA[n-1]
                current_tea_index--;
                update_tea_screen_label();
                update_tea_color();
                update_tea_background();
            }
        }
        else if (ui_screen_state.current_screen == UI_SCREEN_SETTINGS) {
            // SETTINGS → TEA[5] (last tea)
            current_tea_index = MAX_TEA_TYPES - 1;
            _ui_screen_change(&ui_TeaScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_TeaScreen_screen_init);
        }
    }
    else if (knob_event == KNOB_LEFT) {  // Swapped: LEFT now goes right
        // Left rotation → Navigate RIGHT
        if (ui_screen_state.current_screen == UI_SCREEN_MAIN) {
            // MAIN → TEA[0]
            current_tea_index = 0;
            _ui_screen_change(&ui_TeaScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_TeaScreen_screen_init);
        }
        else if (ui_screen_state.current_screen == UI_SCREEN_TEA) {
            if (current_tea_index >= MAX_TEA_TYPES - 1) {
                // TEA[9] → SETTINGS
                _ui_screen_change(&ui_SettingsScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_SettingsScreen_screen_init);
            } else {
                // TEA[n] → TEA[n+1]
                current_tea_index++;
                update_tea_screen_label();
                update_tea_color();
                update_tea_background();
            }
        }
        else if (ui_screen_state.current_screen == UI_SCREEN_SETTINGS) {
            // SETTINGS → MAIN
            _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_MainScreen_screen_init);
        }
    }
    
    lvgl_port_unlock();
}

void LVGL_button_event(void *event) {}

///////////////////// HELPER FUNCTIONS ////////////////////

// Helper function to update tea screen label
void update_tea_screen_label(void)
{
    extern lv_obj_t * ui_TeaName;
    if (ui_TeaName && current_tea_index < MAX_TEA_TYPES) {
        lv_label_set_text(ui_TeaName, tea_names[current_tea_index]);
    }
}

// Helper function to update tea color theme
void update_tea_color(void)
{
    if (current_tea_index < MAX_TEA_TYPES) {
        ui_theme_variable_t *color_ptr = (ui_theme_variable_t *)_ui_theme_color_teacolor;
        color_ptr[0] = tea_colors[current_tea_index];
        _ui_theme_set_variable_styles(UI_VARIABLE_STYLES_MODE_FOLLOW);
    }
}

// Helper function to update tea screen background image
void update_tea_background(void)
{
    extern lv_obj_t * ui_Image1;
    if (ui_Image1 && current_tea_index < MAX_TEA_TYPES) {
        lv_image_set_src(ui_Image1, tea_background_images[current_tea_index]);
    }
}

///////////////////// MOTOR CONTROL FUNCTIONS ////////////////////
void ui_motor_move_to_position(int32_t position)
{
    motor_status_t status;
    uart_comm_get_cached_status(&status);
    
    if (!status.is_connected) {
        ESP_LOGW(TAG_UI, "Motor controller not connected");
        return;
    }
    
    if (!status.is_calibrated) {
        ESP_LOGW(TAG_UI, "Motor not calibrated - please calibrate first");
        return;
    }
    
    if (!status.is_homed) {
        ESP_LOGI(TAG_UI, "Motor not homed, homing first...");
        motor_waiting_for_home = true;
        motor_pending_position = position;
        uart_comm_home();
    } else {
        ESP_LOGI(TAG_UI, "Moving to position: %ld%%", (long)position);
        uart_comm_move_to_percent((float)position);
    }
}

void ui_on_home_complete(bool success)
{
    if (success && motor_waiting_for_home && motor_pending_position >= 0) {
        motor_waiting_for_home = false;
        ESP_LOGI(TAG_UI, "Home complete, moving to position: %ld%%", (long)motor_pending_position);
        uart_comm_move_to_percent((float)motor_pending_position);
        motor_pending_position = -1;
    } else {
        motor_waiting_for_home = false;
        motor_pending_position = -1;
    }
}

// Track if we've done startup motor init
static bool startup_motor_init_done = false;

void ui_on_motor_status_update(const motor_status_t *status)
{
    // Trigger startup motor initialization on first connection
    if (status->is_connected && !startup_motor_init_done) {
        startup_motor_init_done = true;
        ESP_LOGI(TAG_UI, "Motor controller connected - triggering startup motor init");
        ui_startup_motor_init();
    }
}

///////////////////// SCREENS ////////////////////

void ui_init(void)
{
    lv_disp_t * dispp = lv_display_get_default();
    lv_theme_t * theme = lv_theme_default_init(dispp, lv_palette_main(LV_PALETTE_BLUE), lv_palette_main(LV_PALETTE_RED),
                                               false, LV_FONT_DEFAULT);
    lv_disp_set_theme(dispp, theme);
    ui_MainScreen_screen_init();
    ui_TeaScreen_screen_init();
    ui_TeapotScreen_screen_init();
    ui_BrewInfuseScreen_screen_init();
    ui_ErrorScreen_screen_init();
    ui_TeaPropertiesScreen_screen_init();
    ui_BrewNowOrSchedulerScreen_screen_init();
    ui_SettingsScreen_screen_init();
    ui_SchedulerScreen_screen_init();
    ui_ScheduledScreen_screen_init();
    ui____initial_actions0 = lv_obj_create(NULL);
    lv_disp_load_scr(ui_MainScreen);
}

void ui_destroy(void)
{
    ui_MainScreen_screen_destroy();
    ui_TeaScreen_screen_destroy();
    ui_TeapotScreen_screen_destroy();
    ui_BrewInfuseScreen_screen_destroy();
    ui_ErrorScreen_screen_destroy();
    ui_TeaPropertiesScreen_screen_destroy();
    ui_BrewNowOrSchedulerScreen_screen_destroy();
    ui_SettingsScreen_screen_destroy();
    ui_SchedulerScreen_screen_destroy();
    ui_ScheduledScreen_screen_destroy();
}