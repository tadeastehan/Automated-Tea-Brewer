// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.4
// LVGL version: 9.2.2
// Project name: SquareLine_Project

#include "ui.h"
#include "../settings.h"
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/timers.h"
#include "../uart_comm.h"
#include "esp_log.h"
#include "esp_lvgl_port.h"

static const char *TAG = "UI_EVENTS";

/* Set to 1 to show both object and ambient temperature, 0 for object only */
#define TEMPERATURE_DEBUG 0

/* ============================================
   TIMING CONSTANTS
   ============================================ */
#define TEMP_UPDATE_INTERVAL_IDLE_MS      10000   // Temperature update interval when not brewing (10 seconds)
#define TEMP_UPDATE_INTERVAL_BREWING_MS   1000    // Temperature update interval during brewing (1 second)
#define MIN_TEMP_INCREASE_THRESHOLD       10.0f   // Minimum temperature increase expected in warmup period
#define BREWING_WARMUP_TIMEOUT_MS         120000  // 2 minutes - time to check for temperature increase
#define BREWING_MAX_TIMEOUT_MS            (20 * 60 * 1000)  // 20 minutes max brewing time
#define POT_CONFIRMATION_TIME_MS          3000    // 3 seconds - pot must be present this long
#define POT_DETECTION_TIMEOUT_MS          60000   // 60 seconds - max time to wait for pot
#define POT_CHECK_INTERVAL_MS             250     // Check pot presence every 250ms
#define BREWING_POT_CHECK_INTERVAL_MS     5000    // Check pot every 5 seconds during brewing

// Define the screen state variable
ui_screen_state_t ui_screen_state = {0};

// Flags for pending NVS writes
static volatile bool position_save_pending = false;
static volatile bool tea_params_save_pending = false;

// Timer handles
static TimerHandle_t drying_position_save_timer = NULL;
static TimerHandle_t tea_params_save_timer = NULL;
static TimerHandle_t temperature_request_timer = NULL;
static TimerHandle_t pot_check_timer = NULL;
static TimerHandle_t pot_timeout_timer = NULL;
static TimerHandle_t brewing_pot_check_timer = NULL;    // Check pot every 5s during brewing/infusing
static TimerHandle_t brewing_timeout_timer = NULL;      // 20 minute max brewing time
static TimerHandle_t infusion_timer = NULL;             // 1 second timer for infusion countdown
static TimerHandle_t drying_timer = NULL;               // 1 second timer for drying countdown
static TimerHandle_t final_drop_timer = NULL;           // 5 second wait timer for final drop

/* ============================================
   BREWING STATE MACHINE
   ============================================ */
typedef enum {
    BREW_STATE_IDLE = 0,
    BREW_STATE_BREWING,
    BREW_STATE_INFUSING,
    BREW_STATE_DRYING,          // Tea bag drying after infusion
    BREW_STATE_FINAL_DROP,      // Final drop to 100% and back
    BREW_STATE_SCHEDULED
} brew_state_t;

static brew_state_t current_brew_state = BREW_STATE_IDLE;

// Pot detection state
static uint32_t pot_present_start_time = 0;
static bool pot_waiting_for_presence = false;
static bool pot_detection_for_scheduler = false;  // true = scheduler, false = brew now
static volatile bool pot_timeout_triggered = false;  // Flag for timeout handling

// Brewing state
static float brewing_start_temp = 0.0f;  // Room temperature when brewing started
static uint8_t brewing_target_temp = 100;  // Target temperature for brewing
static bool brewing_start_temp_captured = false;  // Flag to capture first temp reading
static uint32_t brewing_start_time = 0;  // Tick count when brewing started
static float last_temp_reading = 0.0f;   // Last temperature reading for progress check

// Infusion state
static uint16_t infusion_target_seconds = 0;  // Target infusion time in seconds
static uint16_t infusion_elapsed_seconds = 0; // Elapsed infusion time in seconds

// Drying state
static uint16_t drying_target_seconds = 0;    // Target drying time in seconds
static uint16_t drying_elapsed_seconds = 0;   // Elapsed drying time in seconds

// Startup motor initialization state
static bool startup_motor_init_pending = true;  // Need to home and move to drying position on startup

// NVS save task handle
static TaskHandle_t nvs_save_task_handle = NULL;

uint8_t current_tea_index = 0;  // Currently selected tea (0 = first tea)

/* Forward declarations */
static void temperature_request_timer_callback(TimerHandle_t xTimer);
static void on_temperature_update(float object_temp, float ambient_temp);
static void pot_check_timer_callback(TimerHandle_t xTimer);
static void pot_timeout_timer_callback(TimerHandle_t xTimer);
static void on_pot_presence_update(bool is_present, uint16_t distance_mm);
static void start_pot_detection(bool for_scheduler);
static void stop_pot_detection(void);

/* Brewing state machine forward declarations */
static void brewing_pot_check_callback(TimerHandle_t xTimer);
static void brewing_timeout_callback(TimerHandle_t xTimer);
static void infusion_timer_callback(TimerHandle_t xTimer);
static void drying_timer_callback(TimerHandle_t xTimer);
static void final_drop_timer_callback(TimerHandle_t xTimer);
static void on_brewing_pot_presence(bool is_present, uint16_t distance_mm);
static void start_brewing_state(void);
static void start_infusing_state(void);
static void start_drying_state(void);
static void start_final_drop_state(void);
static void stop_brew_process(const char *error_message);
static void finish_infusion(void);
static void finish_brew_cycle(void);

/* Motor move complete callback for brewing sequence */
static void on_brewing_move_complete(bool success);

/* ============================================
   NVS SAVE TASK
   ============================================ */

// NVS save task - has enough stack for NVS operations
static void nvs_save_task(void *pvParameters)
{
    ESP_LOGI(TAG, "NVS save task started");
    
    while (1) {
        // Wait for notification (blocks until notified)
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        
        // Small delay to batch multiple rapid changes
        vTaskDelay(pdMS_TO_TICKS(100));
        
        // Save pending changes
        if (position_save_pending) {
            settings_flush_drying_position();
            position_save_pending = false;
            ESP_LOGI(TAG, "Drying position saved to NVS");
        }
        
        if (tea_params_save_pending) {
            settings_flush_tea_params();
            tea_params_save_pending = false;
            ESP_LOGI(TAG, "Tea params saved to NVS");
        }
    }
}

// Initialize NVS save task - call this from app_main
void ui_events_init(void)
{
    if (nvs_save_task_handle == NULL) {
        BaseType_t ret = xTaskCreate(
            nvs_save_task,
            "nvs_save",
            4096,  // 4KB stack - enough for NVS operations
            NULL,
            5,     // Low priority
            &nvs_save_task_handle
        );
        
        if (ret != pdPASS) {
            ESP_LOGE(TAG, "Failed to create NVS save task");
        }
    }
    
    /* Register temperature callback */
    uart_comm_set_temperature_callback(on_temperature_update);
    
    /* Register pot presence callback */
    uart_comm_set_pot_presence_callback(on_pot_presence_update);
    
    /* Create temperature request timer (starts with idle interval) */
    if (temperature_request_timer == NULL) {
        temperature_request_timer = xTimerCreate(
            "temp_timer",
            pdMS_TO_TICKS(TEMP_UPDATE_INTERVAL_IDLE_MS),  // Start with 10 second interval
            pdTRUE,               // Auto-reload
            NULL,
            temperature_request_timer_callback
        );
        
        if (temperature_request_timer != NULL) {
            xTimerStart(temperature_request_timer, 0);
            ESP_LOGI(TAG, "Temperature request timer started (%d ms interval)", TEMP_UPDATE_INTERVAL_IDLE_MS);
        } else {
            ESP_LOGE(TAG, "Failed to create temperature request timer");
        }
    }
}

// Startup motor initialization - home and move to drying position
void ui_startup_motor_init(void)
{
    if (!startup_motor_init_pending) {
        return;  // Already initialized
    }
    
    ESP_LOGI(TAG, "Starting motor initialization - homing and moving to drying position");
    startup_motor_init_pending = false;
    
    // Get stored drying position
    int drying_pos = settings_get_drying_position();
    ESP_LOGI(TAG, "Target drying position: %d%%", drying_pos);
    
    // Use the ui_motor_move_to_drying_position function which handles homing if needed
    ui_motor_move_to_drying_position(drying_pos);
}

/* ============================================
   TIMER CALLBACKS
   ============================================ */

// Timer callback - notify the NVS save task
static void drying_position_save_timer_callback(TimerHandle_t xTimer)
{
    position_save_pending = true;
    if (nvs_save_task_handle != NULL) {
        xTaskNotifyGive(nvs_save_task_handle);
    }
}

// Timer callback for tea params
static void tea_params_save_timer_callback(TimerHandle_t xTimer)
{
    tea_params_save_pending = true;
    if (nvs_save_task_handle != NULL) {
        xTaskNotifyGive(nvs_save_task_handle);
    }
}

// Timer callback for temperature requests (every 5 seconds)
static void temperature_request_timer_callback(TimerHandle_t xTimer)
{
    uart_comm_get_temperature();
}

// Temperature callback - update UI when temperature received
static void on_temperature_update(float object_temp, float ambient_temp)
{
    /* Store last reading for progress checks */
    last_temp_reading = object_temp;
    
    /* Must use LVGL port lock since this is called from UART task */
    if (lvgl_port_lock(100)) {  /* 100ms timeout */
        char temp_str[32];
        
        /* Update the temperature label on MainScreen */
        extern lv_obj_t * ui_Temperature;
        if (ui_Temperature != NULL) {
#if TEMPERATURE_DEBUG
            snprintf(temp_str, sizeof(temp_str), "%.1f °C\n%.1f °C", object_temp, ambient_temp);
#else
            snprintf(temp_str, sizeof(temp_str), "%.1f °C", object_temp);
#endif
            lv_label_set_text(ui_Temperature, temp_str);
        }
        
        /* Handle BREWING state */
        if (current_brew_state == BREW_STATE_BREWING) {
            extern lv_obj_t * ui_BrewInfuseCurrentValue;
            extern lv_obj_t * ui_brewingArc;
            
            /* Capture starting temperature on first reading */
            if (!brewing_start_temp_captured) {
                brewing_start_temp = object_temp;
                brewing_start_temp_captured = true;
                brewing_start_time = xTaskGetTickCount();
                ESP_LOGI(TAG, "Brewing start temp captured: %.1f °C, target: %d °C", 
                         brewing_start_temp, brewing_target_temp);
            }
            
            /* Check if temperature hasn't increased by threshold after warmup timeout */
            uint32_t elapsed_ms = (xTaskGetTickCount() - brewing_start_time) * portTICK_PERIOD_MS;
            if (elapsed_ms >= BREWING_WARMUP_TIMEOUT_MS) {
                if (object_temp < brewing_start_temp + MIN_TEMP_INCREASE_THRESHOLD) {
                    lvgl_port_unlock();
                    stop_brew_process("Teapot took too long to start heating. Please check the heating element.");
                    return;
                }
            }
            
            /* Check if target temperature reached - transition to INFUSING */
            if (object_temp >= (float)brewing_target_temp) {
                ESP_LOGI(TAG, "Target temperature reached! Transitioning to INFUSING state");
                lvgl_port_unlock();
                start_infusing_state();
                return;
            }
            
            /* Update current temperature label */
            if (ui_BrewInfuseCurrentValue != NULL) {
                snprintf(temp_str, sizeof(temp_str), "%.1f °C", object_temp);
                lv_label_set_text(ui_BrewInfuseCurrentValue, temp_str);
            }
            
            /* Update arc progress */
            if (ui_brewingArc != NULL) {
                int32_t arc_value = 0;
                
                /* Calculate progress: 0% at room temp, 100% at target temp */
                float temp_range = (float)brewing_target_temp - brewing_start_temp;
                if (temp_range > 0.0f) {
                    float progress = (object_temp - brewing_start_temp) / temp_range * 100.0f;
                    
                    /* Clamp to 0-100 range */
                    if (progress < 0.0f) {
                        arc_value = 0;
                    } else if (progress > 100.0f) {
                        arc_value = 100;
                    } else {
                        arc_value = (int32_t)progress;
                    }
                }
                
                lv_arc_set_value(ui_brewingArc, arc_value);
            }
        }
        
        lvgl_port_unlock();
    }
}

/* ============================================
   BREWING STATE MACHINE FUNCTIONS
   ============================================ */

// Pot check during brewing/infusing (every 5 seconds)
static void brewing_pot_check_callback(TimerHandle_t xTimer)
{
    if (current_brew_state == BREW_STATE_BREWING || current_brew_state == BREW_STATE_INFUSING) {
        uart_comm_get_pot_presence();
    }
}

// Handle pot presence response during brewing/infusing
static void on_brewing_pot_presence(bool is_present, uint16_t distance_mm)
{
    if (!is_present) {
        ESP_LOGW(TAG, "Pot removed during %s!", 
                 current_brew_state == BREW_STATE_BREWING ? "brewing" : "infusing");
        stop_brew_process("Teapot was removed during the brewing process.");
    }
}

// Brewing timeout callback (20 minutes)
static void brewing_timeout_callback(TimerHandle_t xTimer)
{
    if (current_brew_state == BREW_STATE_BREWING) {
        ESP_LOGW(TAG, "Brewing timeout (20 minutes)");
        stop_brew_process("Tea took too long to reach the target temperature. Please check the heating element.");
    }
}

// Infusion timer callback (every 1 second)
static void infusion_timer_callback(TimerHandle_t xTimer)
{
    if (current_brew_state != BREW_STATE_INFUSING) {
        return;
    }
    
    infusion_elapsed_seconds++;
    
    // Check if infusion complete
    if (infusion_elapsed_seconds >= infusion_target_seconds) {
        finish_infusion();
        return;
    }
    
    // Update UI
    if (lvgl_port_lock(100)) {
        extern lv_obj_t * ui_BrewInfuseCurrentValue;
        extern lv_obj_t * ui_brewingArc;
        
        // Update elapsed time display (mm:ss)
        if (ui_BrewInfuseCurrentValue != NULL) {
            char time_str[16];
            uint16_t mins = infusion_elapsed_seconds / 60;
            uint16_t secs = infusion_elapsed_seconds % 60;
            snprintf(time_str, sizeof(time_str), "%02d:%02d", mins, secs);
            lv_label_set_text(ui_BrewInfuseCurrentValue, time_str);
        }
        
        // Update arc progress (0-100 based on elapsed/target)
        if (ui_brewingArc != NULL) {
            int32_t arc_value = 0;
            if (infusion_target_seconds > 0) {
                arc_value = (infusion_elapsed_seconds * 100) / infusion_target_seconds;
                if (arc_value > 100) arc_value = 100;
            }
            lv_arc_set_value(ui_brewingArc, arc_value);
        }
        
        lvgl_port_unlock();
    }
}

// Start the brewing state
static void start_brewing_state(void)
{
    current_brew_state = BREW_STATE_BREWING;
    brewing_start_temp_captured = false;
    brewing_start_temp = 25.0f;
    brewing_start_time = 0;
    
    // Get target temperature
    brewing_target_temp = settings_get_tea_temperature(current_tea_index);
    
    ESP_LOGI(TAG, "Starting brew - target temp: %d °C", brewing_target_temp);
    
    // Move motor to drying position (tea bag in water)
    int drying_pos = settings_get_drying_position();
    ESP_LOGI(TAG, "Moving to drying position: %d%%", drying_pos);
    uart_comm_set_move_complete_callback(on_brewing_move_complete);
    uart_comm_move_to_percent((float)drying_pos);
    
    // Turn on induction cooker
    uart_comm_induction_on();
    
    // Switch temperature timer to fast interval (1 second) during brewing
    if (temperature_request_timer != NULL) {
        xTimerChangePeriod(temperature_request_timer, pdMS_TO_TICKS(TEMP_UPDATE_INTERVAL_BREWING_MS), 0);
        ESP_LOGI(TAG, "Temperature timer switched to %d ms interval", TEMP_UPDATE_INTERVAL_BREWING_MS);
    }
    
    // Create pot check timer (5 second interval)
    if (brewing_pot_check_timer == NULL) {
        brewing_pot_check_timer = xTimerCreate(
            "brew_pot",
            pdMS_TO_TICKS(BREWING_POT_CHECK_INTERVAL_MS),
            pdTRUE,  // Auto-reload
            NULL,
            brewing_pot_check_callback
        );
    }
    
    // Create brewing timeout timer (max brewing time, one-shot)
    if (brewing_timeout_timer == NULL) {
        brewing_timeout_timer = xTimerCreate(
            "brew_timeout",
            pdMS_TO_TICKS(BREWING_MAX_TIMEOUT_MS),
            pdFALSE,  // One-shot
            NULL,
            brewing_timeout_callback
        );
    }
    
    // Start timers
    if (brewing_pot_check_timer != NULL) {
        xTimerStart(brewing_pot_check_timer, 0);
    }
    if (brewing_timeout_timer != NULL) {
        xTimerStart(brewing_timeout_timer, 0);
    }
}

// Transition to infusing state
static void start_infusing_state(void)
{
    current_brew_state = BREW_STATE_INFUSING;
    
    // Turn off induction cooker - water is hot enough
    uart_comm_induction_off();
    
    // Move motor to 0% position (tea bag fully in water for infusion)
    ESP_LOGI(TAG, "Moving to 0%% position for infusion");
    uart_comm_move_to_percent(0.0f);
    
    // Stop brewing timeout timer (no longer needed)
    if (brewing_timeout_timer != NULL) {
        xTimerStop(brewing_timeout_timer, 0);
    }
    
    // Get infusion time from settings
    infusion_target_seconds = settings_get_tea_infusion_time(current_tea_index);
    infusion_elapsed_seconds = 0;
    
    ESP_LOGI(TAG, "Starting infusion - target time: %d seconds", infusion_target_seconds);
    
    // Update UI for infusion mode
    if (lvgl_port_lock(100)) {
        extern lv_obj_t * ui_BrewInfuseTitle;
        extern lv_obj_t * ui_BrewInfuseCurrentValue;
        extern lv_obj_t * ui_BrewInfuseSetValue;
        extern lv_obj_t * ui_brewingArc;
        
        // Change title to "Infuse"
        if (ui_BrewInfuseTitle != NULL) {
            lv_label_set_text(ui_BrewInfuseTitle, "Infuse");
        }
        
        // Set current value to 00:00
        if (ui_BrewInfuseCurrentValue != NULL) {
            lv_label_set_text(ui_BrewInfuseCurrentValue, "00:00");
        }
        
        // Set target time display (mm:ss)
        if (ui_BrewInfuseSetValue != NULL) {
            char time_str[16];
            uint16_t mins = infusion_target_seconds / 60;
            uint16_t secs = infusion_target_seconds % 60;
            snprintf(time_str, sizeof(time_str), "%02d:%02d", mins, secs);
            lv_label_set_text(ui_BrewInfuseSetValue, time_str);
        }
        
        // Reset arc to 0
        if (ui_brewingArc != NULL) {
            lv_arc_set_value(ui_brewingArc, 0);
        }
        
        lvgl_port_unlock();
    }
    
    // Create infusion timer (1 second interval)
    if (infusion_timer == NULL) {
        infusion_timer = xTimerCreate(
            "infuse",
            pdMS_TO_TICKS(1000),
            pdTRUE,  // Auto-reload
            NULL,
            infusion_timer_callback
        );
    }
    
    // Start infusion timer
    if (infusion_timer != NULL) {
        xTimerStart(infusion_timer, 0);
    }
}

// Stop brewing/infusing process with error
static void stop_brew_process(const char *error_message)
{
    ESP_LOGW(TAG, "Stopping brew process: %s", error_message);
    
    // Turn off induction cooker immediately
    uart_comm_induction_off();
    
    // Stop all brewing-related timers
    if (brewing_pot_check_timer != NULL) {
        xTimerStop(brewing_pot_check_timer, 0);
    }
    if (brewing_timeout_timer != NULL) {
        xTimerStop(brewing_timeout_timer, 0);
    }
    if (infusion_timer != NULL) {
        xTimerStop(infusion_timer, 0);
    }
    
    // Switch temperature timer back to slow interval (10 seconds)
    if (temperature_request_timer != NULL) {
        xTimerChangePeriod(temperature_request_timer, pdMS_TO_TICKS(TEMP_UPDATE_INTERVAL_IDLE_MS), 0);
        ESP_LOGI(TAG, "Temperature timer switched to %d ms interval", TEMP_UPDATE_INTERVAL_IDLE_MS);
    }
    
    // Reset state
    current_brew_state = BREW_STATE_IDLE;
    brewing_start_temp_captured = false;
    
    // Show error screen
    if (lvgl_port_lock(100)) {
        extern lv_obj_t * ui_ErrorScreen;
        extern lv_obj_t * ui_TextArea1;
        
        if (ui_ErrorScreen) {
            _ui_screen_change(&ui_ErrorScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_ErrorScreen_screen_init);
        }
        
        if (ui_TextArea1 && error_message) {
            lv_textarea_set_text(ui_TextArea1, error_message);
        }
        
        lvgl_port_unlock();
    }
}

// Finish infusion - go to main screen and start background drying process
static void finish_infusion(void)
{
    ESP_LOGI(TAG, "Infusion complete - going to main screen and starting background drying");
    
    // Stop infusion timer
    if (infusion_timer != NULL) {
        xTimerStop(infusion_timer, 0);
    }
    
    // Stop pot check timer (no longer on brew screen)
    if (brewing_pot_check_timer != NULL) {
        xTimerStop(brewing_pot_check_timer, 0);
    }
    
    // Change temperature update back to slow interval (idle mode)
    if (temperature_request_timer != NULL) {
        xTimerChangePeriod(temperature_request_timer, pdMS_TO_TICKS(TEMP_UPDATE_INTERVAL_IDLE_MS), 0);
        ESP_LOGI(TAG, "Temperature update interval changed to %d ms (idle mode)", TEMP_UPDATE_INTERVAL_IDLE_MS);
    }
    
    // Go to main screen first
    if (lvgl_port_lock(100)) {
        extern lv_obj_t * ui_MainScreen;
        if (ui_MainScreen) {
            _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_MainScreen_screen_init);
        }
        lvgl_port_unlock();
    }
    
    // Start background drying state
    start_drying_state();
}

// Start the drying state - tea bag lifted to drying position (background process, no UI)
static void start_drying_state(void)
{
    current_brew_state = BREW_STATE_DRYING;
    
    // Get drying time from settings (stored as minutes)
    uint8_t drying_time_minutes = settings_get_drying_time();
    drying_target_seconds = drying_time_minutes * 60;  // Convert to seconds
    drying_elapsed_seconds = 0;
    
    ESP_LOGI(TAG, "Starting background drying - target time: %d minutes (%d seconds)", 
             drying_time_minutes, drying_target_seconds);
    
    // Move motor to drying position (stored position)
    int drying_pos = settings_get_drying_position();
    ESP_LOGI(TAG, "Moving to drying position: %d%%", drying_pos);
    uart_comm_move_to_percent((float)drying_pos);
    
    // Create drying timer (1 second interval)
    if (drying_timer == NULL) {
        drying_timer = xTimerCreate(
            "drying",
            pdMS_TO_TICKS(1000),
            pdTRUE,  // Auto-reload
            NULL,
            drying_timer_callback
        );
    }
    
    // Start drying timer
    if (drying_timer != NULL) {
        xTimerStart(drying_timer, 0);
    }
}

// Drying timer callback - check completion (no UI updates, background process)
static void drying_timer_callback(TimerHandle_t xTimer)
{
    drying_elapsed_seconds++;
    
    // Log progress every 30 seconds
    if (drying_elapsed_seconds % 30 == 0) {
        ESP_LOGI(TAG, "Drying progress: %d/%d seconds", drying_elapsed_seconds, drying_target_seconds);
    }
    
    // Check if drying is complete
    if (drying_elapsed_seconds >= drying_target_seconds) {
        ESP_LOGI(TAG, "Drying complete - starting final drop");
        xTimerStop(drying_timer, 0);
        start_final_drop_state();
    }
}

// Start final drop state - drop to 100%, wait 5s, return to drying position (background, no UI)
static void start_final_drop_state(void)
{
    current_brew_state = BREW_STATE_FINAL_DROP;
    
    ESP_LOGI(TAG, "Starting final drop - moving to 100%% position");
    
    // Move motor to 100% position (fully lowered for final drops)
    uart_comm_set_move_complete_callback(on_brewing_move_complete);
    uart_comm_move_to_percent(100.0f);
}

// Final drop timer callback - 5 seconds at 100%, then back to drying position
static void final_drop_timer_callback(TimerHandle_t xTimer)
{
    ESP_LOGI(TAG, "Final drop wait complete - returning to drying position");
    xTimerStop(final_drop_timer, 0);
    
    // Move back to drying position
    int drying_pos = settings_get_drying_position();
    ESP_LOGI(TAG, "Moving to drying position: %d%%", drying_pos);
    uart_comm_set_move_complete_callback(on_brewing_move_complete);
    uart_comm_move_to_percent((float)drying_pos);
}

// Motor move complete callback for brewing sequence
static void on_brewing_move_complete(bool success)
{
    if (!success) {
        ESP_LOGW(TAG, "Motor move failed during brewing sequence");
        return;
    }
    
    if (current_brew_state == BREW_STATE_FINAL_DROP) {
        // Check current motor position to determine next action
        motor_status_t status;
        uart_comm_get_cached_status(&status);
        
        // If we just reached 100%, start 5 second wait timer
        if (status.position_percent >= 99.0f) {
            ESP_LOGI(TAG, "Reached 100%% position - waiting 5 seconds");
            
            // Create final drop timer (5 second one-shot)
            if (final_drop_timer == NULL) {
                final_drop_timer = xTimerCreate(
                    "final_drop",
                    pdMS_TO_TICKS(5000),
                    pdFALSE,  // One-shot
                    NULL,
                    final_drop_timer_callback
                );
            }
            
            if (final_drop_timer != NULL) {
                xTimerStart(final_drop_timer, 0);
            }
        } else {
            // We've returned to drying position - brewing cycle complete
            finish_brew_cycle();
        }
    }
}

// Finish the entire brew cycle
static void finish_brew_cycle(void)
{
    ESP_LOGI(TAG, "Brew cycle complete!");
    
    // Stop all brewing-related timers
    if (brewing_pot_check_timer != NULL) {
        xTimerStop(brewing_pot_check_timer, 0);
    }
    if (drying_timer != NULL) {
        xTimerStop(drying_timer, 0);
    }
    if (final_drop_timer != NULL) {
        xTimerStop(final_drop_timer, 0);
    }
    
    // Reset state (already on main screen, temperature timer already slow)
    current_brew_state = BREW_STATE_IDLE;
    brewing_start_temp_captured = false;
    
    // Clear move complete callback
    uart_comm_set_move_complete_callback(NULL);
    
    ESP_LOGI(TAG, "Background drying and final drop complete - motor at drying position");
}

/* ============================================
   POT DETECTION FUNCTIONS
   ============================================ */

// Pot presence callback - called from UART task when pot presence response received
static void on_pot_presence_update(bool is_present, uint16_t distance_mm)
{
    // Check if this is for brewing/infusing pot monitoring
    if (current_brew_state == BREW_STATE_BREWING || current_brew_state == BREW_STATE_INFUSING) {
        on_brewing_pot_presence(is_present, distance_mm);
        return;
    }
    
    if (!pot_waiting_for_presence) {
        return;  // Not waiting for pot, ignore
    }
    
    // Check if timeout was triggered
    if (pot_timeout_triggered) {
        ESP_LOGW(TAG, "Handling pot timeout - showing error screen");
        pot_timeout_triggered = false;
        stop_pot_detection();
        
        // Switch to ErrorScreen and show error message
        if (lvgl_port_lock(100)) {
            extern lv_obj_t * ui_ErrorScreen;
            extern lv_obj_t * ui_TextArea1;
            
            if (ui_ErrorScreen) {
                _ui_screen_change(&ui_ErrorScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_ErrorScreen_screen_init);
            }
            
            if (ui_TextArea1) {
                lv_textarea_set_text(ui_TextArea1, "Teapot was not detected for 60 seconds.");
            }
            
            lvgl_port_unlock();
        }
        return;
    }
    
    ESP_LOGD(TAG, "Pot presence: %s, distance: %u mm", is_present ? "YES" : "NO", distance_mm);
    
    if (is_present) {
        // Pot detected
        if (pot_present_start_time == 0) {
            // First detection - start the 3 second timer
            pot_present_start_time = xTaskGetTickCount();
            ESP_LOGI(TAG, "Pot detected, waiting 3 seconds for confirmation...");
        } else {
            // Check if pot has been present for confirmation time
            uint32_t elapsed_ms = ((TickType_t)xTaskGetTickCount() - (TickType_t)pot_present_start_time) * portTICK_PERIOD_MS;
            if (elapsed_ms >= POT_CONFIRMATION_TIME_MS) {
                // Pot confirmed present for 3 seconds - proceed
                ESP_LOGI(TAG, "Pot confirmed present for 3 seconds!");
                bool for_scheduler = pot_detection_for_scheduler;
                stop_pot_detection();
                
                if (lvgl_port_lock(100)) {
                    if (for_scheduler) {
                        // Scheduler mode - go to ScheduledScreen
                        ESP_LOGI(TAG, "Starting scheduler...");
                        extern lv_obj_t * ui_ScheduledScreen;
                        if (ui_ScheduledScreen) {
                            _ui_screen_change(&ui_ScheduledScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_ScheduledScreen_screen_init);
                        }
                    } else {
                        // Brew now mode - go to BrewInfuseScreen
                        ESP_LOGI(TAG, "Starting brew...");
                        extern lv_obj_t * ui_BrewInfuseScreen;
                        if (ui_BrewInfuseScreen) {
                            _ui_screen_change(&ui_BrewInfuseScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_BrewInfuseScreen_screen_init);
                        }
                        
                        // Update brewing title
                        extern lv_obj_t * ui_BrewInfuseTitle;
                        if (ui_BrewInfuseTitle) {
                            lv_label_set_text(ui_BrewInfuseTitle, "Brew");
                        }
                    }
                    lvgl_port_unlock();
                }
            }
        }
    } else {
        // Pot not detected - reset the confirmation timer
        if (pot_present_start_time != 0) {
            ESP_LOGI(TAG, "Pot removed, resetting confirmation timer");
            pot_present_start_time = 0;
        }
    }
}

// Timer callback - request pot presence every 250ms
static void pot_check_timer_callback(TimerHandle_t xTimer)
{
    if (pot_waiting_for_presence) {
        uart_comm_get_pot_presence();
    }
}

// Timer callback - 60 second timeout
// NOTE: Keep this minimal - timer callbacks have limited stack!
static void pot_timeout_timer_callback(TimerHandle_t xTimer)
{
    ESP_LOGW(TAG, "Pot detection timeout (60s)");
    pot_timeout_triggered = true;
    // Stop the check timer
    if (pot_check_timer != NULL) {
        xTimerStop(pot_check_timer, 0);
    }
    // Request one final pot presence check - the response callback will handle the timeout UI
    uart_comm_get_pot_presence();
}

// Start pot detection process
static void start_pot_detection(bool for_scheduler)
{
    pot_waiting_for_presence = true;
    pot_present_start_time = 0;
    pot_detection_for_scheduler = for_scheduler;
    
    // Create pot check timer (250ms interval)
    if (pot_check_timer == NULL) {
        pot_check_timer = xTimerCreate(
            "pot_check",
            pdMS_TO_TICKS(POT_CHECK_INTERVAL_MS),
            pdTRUE,  // Auto-reload
            NULL,
            pot_check_timer_callback
        );
    }
    
    // Create pot timeout timer (one-shot)
    if (pot_timeout_timer == NULL) {
        pot_timeout_timer = xTimerCreate(
            "pot_timeout",
            pdMS_TO_TICKS(POT_DETECTION_TIMEOUT_MS),
            pdFALSE,  // One-shot
            NULL,
            pot_timeout_timer_callback
        );
    }
    
    // Start timers
    if (pot_check_timer != NULL) {
        xTimerStart(pot_check_timer, 0);
    }
    if (pot_timeout_timer != NULL) {
        xTimerStart(pot_timeout_timer, 0);
    }
    
    // Request initial pot presence
    uart_comm_get_pot_presence();
    
    ESP_LOGI(TAG, "Pot detection started (60s timeout, mode: %s)", 
             for_scheduler ? "scheduler" : "brew now");
}

// Stop pot detection process
static void stop_pot_detection(void)
{
    pot_waiting_for_presence = false;
    pot_present_start_time = 0;
    pot_timeout_triggered = false;  // Reset timeout flag
    
    if (pot_check_timer != NULL) {
        xTimerStop(pot_check_timer, 0);
    }
    if (pot_timeout_timer != NULL) {
        xTimerStop(pot_timeout_timer, 0);
    }
    
    ESP_LOGI(TAG, "Pot detection stopped");
}

// Call this on screen changes (optional extra safety)
void check_and_save_pending_nvs(void)
{
    // If there are pending saves and task exists, trigger save
    if ((position_save_pending || tea_params_save_pending) && nvs_save_task_handle != NULL) {
        xTaskNotifyGive(nvs_save_task_handle);
    }
}

/* ============================================
   EVENT HANDLERS
   ============================================ */
void stopBrewing(lv_event_t * e)
{
    if (current_brew_state == BREW_STATE_INFUSING) {
        ESP_LOGI(TAG, "Stopped during infusing");
    } else if (current_brew_state == BREW_STATE_BREWING) {
        ESP_LOGI(TAG, "Stopping brew");
    } else if (current_brew_state == BREW_STATE_DRYING) {
        ESP_LOGI(TAG, "Stopped during drying");
    } else if (current_brew_state == BREW_STATE_FINAL_DROP) {
        ESP_LOGI(TAG, "Stopped during final drop");
    }
    
    // Turn off induction cooker
    uart_comm_induction_off();
    
    // Stop all brewing-related timers
    if (brewing_pot_check_timer != NULL) {
        xTimerStop(brewing_pot_check_timer, 0);
    }
    if (brewing_timeout_timer != NULL) {
        xTimerStop(brewing_timeout_timer, 0);
    }
    if (infusion_timer != NULL) {
        xTimerStop(infusion_timer, 0);
    }
    if (drying_timer != NULL) {
        xTimerStop(drying_timer, 0);
    }
    if (final_drop_timer != NULL) {
        xTimerStop(final_drop_timer, 0);
    }
    
    // Clear move complete callback
    uart_comm_set_move_complete_callback(NULL);
    
    // Move motor back to drying position (safe position)
    int drying_pos = settings_get_drying_position();
    ESP_LOGI(TAG, "Moving to drying position: %d%%", drying_pos);
    uart_comm_move_to_percent((float)drying_pos);
    
    // Change temperature update back to slow interval (idle mode)
    if (temperature_request_timer != NULL) {
        xTimerChangePeriod(temperature_request_timer, pdMS_TO_TICKS(TEMP_UPDATE_INTERVAL_IDLE_MS), 0);
        ESP_LOGI(TAG, "Temperature update interval changed to %d ms (idle mode)", TEMP_UPDATE_INTERVAL_IDLE_MS);
    }
    
    // Reset state
    current_brew_state = BREW_STATE_IDLE;
    brewing_start_temp_captured = false;
    
    // Navigate back to MainScreen
    extern lv_obj_t * ui_MainScreen;
    if (ui_MainScreen) {
        _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_MainScreen_screen_init);
    }
}

void nextTeaScreen(lv_event_t * e)
{
    // Get the touch position from the event
    lv_point_t point;
    lv_indev_t * indev = lv_event_get_indev(e);
    if (indev) {
        lv_indev_get_point(indev, &point);
    } else {
        indev = lv_indev_active();
        if (indev) {
            lv_indev_get_point(indev, &point);
        } else {
            ESP_LOGW(TAG, "No input device found, defaulting to right side behavior");
            point.x = 320;  // Default to right side
        }
    }
    
    // Determine if touch is on left side (x <= 240) or right side (x > 240)
    bool is_left_side = (point.x <= 240);
    
    // Handle Main Screen
    if (ui_screen_state.current_screen == UI_SCREEN_MAIN) {
        if (is_left_side) {
            // Left side on main screen -> go to settings
            extern lv_obj_t * ui_SettingsScreen;
            if (ui_SettingsScreen) {
                _ui_screen_change(&ui_SettingsScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_SettingsScreen_screen_init);
            }
        } else {
            // Right side on main screen -> go to tea 0
            current_tea_index = 0;
            extern lv_obj_t * ui_TeaScreen;
            if (ui_TeaScreen) {
                _ui_screen_change(&ui_TeaScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_TeaScreen_screen_init);
            }
        }
        return;
    }
    
    // Handle Settings Screen
    if (ui_screen_state.current_screen == UI_SCREEN_SETTINGS) {
        if (is_left_side) {
            // Left side on settings screen -> go to last tea
            current_tea_index = MAX_TEA_TYPES - 1;
            extern lv_obj_t * ui_TeaScreen;
            if (ui_TeaScreen) {
                _ui_screen_change(&ui_TeaScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_TeaScreen_screen_init);
            }
        } else {
            // Right side on settings screen -> go to main screen
            extern lv_obj_t * ui_MainScreen;
            if (ui_MainScreen) {
                _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_MainScreen_screen_init);
            }
        }
        return;
    }
    
    // Handle Tea Screen navigation
    if (is_left_side) {
        // Left side - go to previous tea
        if (current_tea_index > 0) {
            current_tea_index--;
            update_tea_screen_label();
            update_tea_color();
            update_tea_background();
        } else {
            // If at first tea (index 0), go back to main screen
            extern lv_obj_t * ui_MainScreen;
            if (ui_MainScreen) {
                _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_MainScreen_screen_init);
            }
        }
    } else {
        // Right side - go to next tea
        if (current_tea_index < MAX_TEA_TYPES - 1) {
            current_tea_index++;
            update_tea_screen_label();
            update_tea_color();
            update_tea_background();
        } else {
            // If at last tea, go to settings screen
            extern lv_obj_t * ui_SettingsScreen;
            if (ui_SettingsScreen) {
                _ui_screen_change(&ui_SettingsScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_SettingsScreen_screen_init);
            }
        }
    }
}

void changeScreenToTeaPropertiesScreen(lv_event_t * e)
{
    // Your code here
}

void changeTeaTemperature(lv_event_t * e)
{
    // Your code here
}

void changeInfusionTimeSecond(lv_event_t * e)
{
    lv_obj_t * roller = lv_event_get_target(e);
    if (roller) {
        uint16_t selected_seconds = lv_roller_get_selected(roller);
        
        // Get current infusion time and update only seconds
        uint16_t current_time = settings_get_tea_infusion_time(current_tea_index);
        uint16_t minutes = current_time / 60;
        uint16_t new_time = (minutes * 60) + selected_seconds;
        
        settings_set_tea_infusion_time_no_save(current_tea_index, new_time);
        
        // Create or reset timer
        if (tea_params_save_timer == NULL) {
            tea_params_save_timer = xTimerCreate(
                "TeaParamsSave",
                pdMS_TO_TICKS(10000),
                pdFALSE,
                0,
                tea_params_save_timer_callback
            );
        }
        
        if (tea_params_save_timer != NULL) {
            xTimerReset(tea_params_save_timer, 0);
        }
    }
}

void changeInfusionTimeMinute(lv_event_t * e)
{
    lv_obj_t * roller = lv_event_get_target(e);
    if (roller) {
        uint16_t selected_minutes = lv_roller_get_selected(roller);
        
        // Get current infusion time and update only minutes
        uint16_t current_time = settings_get_tea_infusion_time(current_tea_index);
        uint16_t seconds = current_time % 60;
        uint16_t new_time = (selected_minutes * 60) + seconds;
        
        settings_set_tea_infusion_time_no_save(current_tea_index, new_time);
        
        // Create or reset timer
        if (tea_params_save_timer == NULL) {
            tea_params_save_timer = xTimerCreate(
                "TeaParamsSave",
                pdMS_TO_TICKS(10000),
                pdFALSE,
                0,
                tea_params_save_timer_callback
            );
        }
        
        if (tea_params_save_timer != NULL) {
            xTimerReset(tea_params_save_timer, 0);
        }
    }
}

void ReturnToTeaScreen(lv_event_t * e)
{
    // Your code here
}

void brewNow(lv_event_t * e)
{
    ESP_LOGI(TAG, "Brew Now pressed, checking pot presence...");
    
    // First check if pot is already present (quick check)
    bool is_present = false;
    uint16_t distance_mm = 0;
    uart_comm_get_cached_pot_presence(&is_present, &distance_mm);
    
    if (is_present) {
        // Pot seems to be present, but we still need 3 second confirmation
        // Go to TeapotScreen and start detection
        ESP_LOGI(TAG, "Pot may be present (cached), starting confirmation...");
    }
    
    // Switch to TeapotScreen
    extern lv_obj_t * ui_TeapotScreen;
    if (ui_TeapotScreen) {
        _ui_screen_change(&ui_TeapotScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_TeapotScreen_screen_init);
    }
    
    // Start pot detection process (for brew now, not scheduler)
    start_pot_detection(false);
}

void changeBrewingTeaTemperature(lv_event_t * e)
{
    lv_obj_t * roller = lv_event_get_target(e);
    if (roller) {
        uint16_t selected = lv_roller_get_selected(roller);
        // Temperature options: 75, 80, 85, 90, 95, 100
        uint8_t temperature = 75 + (selected * 5);
        settings_set_tea_temperature_no_save(current_tea_index, temperature);
        
        // Create or reset timer for delayed NVS write (10 seconds)
        if (tea_params_save_timer == NULL) {
            tea_params_save_timer = xTimerCreate(
                "TeaParamsSave",
                pdMS_TO_TICKS(10000),
                pdFALSE,
                0,
                tea_params_save_timer_callback
            );
        }
        
        if (tea_params_save_timer != NULL) {
            xTimerReset(tea_params_save_timer, 0);
        }
    }
}

void changeDryingTime(lv_event_t * e)
{
    lv_obj_t * roller = lv_event_get_target(e);
    if (roller) {
        uint16_t selected = lv_roller_get_selected(roller);
        settings_set_drying_time((uint8_t)selected);
    }
}

void dryingPositionUp(lv_event_t * e)
{
    int current_position = settings_get_drying_position();
    
    // Limit to 0-100 range
    if (current_position >= 100) {
        ESP_LOGW(TAG, "Drying position already at maximum (100%%)");
        return;
    }
    
    current_position++;
    settings_set_drying_position_no_save(current_position);
    
    // Move motor to new position
    ui_motor_move_to_drying_position(current_position);
    
    ESP_LOGI(TAG, "Drying position UP: %d%%", current_position);
    
    // Create or reset timer for delayed NVS write (10 seconds)
    if (drying_position_save_timer == NULL) {
        drying_position_save_timer = xTimerCreate(
            "DryingPosSave",
            pdMS_TO_TICKS(10000),
            pdFALSE,
            0,
            drying_position_save_timer_callback
        );
    }
    
    if (drying_position_save_timer != NULL) {
        xTimerReset(drying_position_save_timer, 0);
    }
}

void dryingPositionDown(lv_event_t * e)
{
    int current_position = settings_get_drying_position();
    
    // Limit to 0-100 range
    if (current_position <= 0) {
        ESP_LOGW(TAG, "Drying position already at minimum (0%%)");
        return;
    }
    
    current_position--;
    settings_set_drying_position_no_save(current_position);
    
    // Move motor to new position
    ui_motor_move_to_drying_position(current_position);
    
    ESP_LOGI(TAG, "Drying position DOWN: %d%%", current_position);
    
    // Create or reset timer for delayed NVS write (10 seconds)
    if (drying_position_save_timer == NULL) {
        drying_position_save_timer = xTimerCreate(
            "DryingPosSave",
            pdMS_TO_TICKS(10000),
            pdFALSE,
            0,
            drying_position_save_timer_callback
        );
    }
    
    if (drying_position_save_timer != NULL) {
        xTimerReset(drying_position_save_timer, 0);
    }
}

void changeSchedulerTemperature(lv_event_t * e)
{
    // Your code here
}

void changeSchedulerTimeMinute(lv_event_t * e)
{
    // Your code here
}

void changeSchedulerTimeHour(lv_event_t * e)
{
    // Your code here
}

void beginScheduler(lv_event_t * e)
{
    ESP_LOGI(TAG, "Begin Scheduler pressed, checking pot presence...");
    
    // First check if pot is already present (quick check)
    bool is_present = false;
    uint16_t distance_mm = 0;
    uart_comm_get_cached_pot_presence(&is_present, &distance_mm);
    
    if (is_present) {
        // Pot seems to be present, but we still need 3 second confirmation
        ESP_LOGI(TAG, "Pot may be present (cached), starting confirmation...");
    }
    
    // Switch to TeapotScreen
    extern lv_obj_t * ui_TeapotScreen;
    if (ui_TeapotScreen) {
        _ui_screen_change(&ui_TeapotScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_TeapotScreen_screen_init);
    }
    
    // Start pot detection process (for scheduler)
    start_pot_detection(true);
}

void stopScheduledBrew(lv_event_t * e)
{
    // Your code here
}

void onMainScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_MAIN;
    check_and_save_pending_nvs();
    
    // Stop pot detection if it was running
    if (pot_waiting_for_presence) {
        stop_pot_detection();
    }
    
    // Reset brewing state if we got here somehow during brewing
    if (current_brew_state != BREW_STATE_IDLE) {
        if (brewing_pot_check_timer != NULL) {
            xTimerStop(brewing_pot_check_timer, 0);
        }
        if (brewing_timeout_timer != NULL) {
            xTimerStop(brewing_timeout_timer, 0);
        }
        if (infusion_timer != NULL) {
            xTimerStop(infusion_timer, 0);
        }
        current_brew_state = BREW_STATE_IDLE;
        brewing_start_temp_captured = false;
    }
}

void onTeaScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_TEA;
    check_and_save_pending_nvs();
    update_tea_screen_label();
    update_tea_color();
    update_tea_background();
}

void onTeapotScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_TEAPOT;
    check_and_save_pending_nvs();
    // Note: pot detection is started by brewNow(), not here
}

void onBrewInfuseScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_BREW_INFUSE;
    check_and_save_pending_nvs();
    
    // Stop pot detection if it was still running (shouldn't be, but just in case)
    if (pot_waiting_for_presence) {
        stop_pot_detection();
    }
    
    // Start the brewing state machine
    start_brewing_state();
    
    // Update the set value label with target temperature
    extern lv_obj_t * ui_BrewInfuseSetValue;
    extern lv_obj_t * ui_BrewInfuseTitle;
    extern lv_obj_t * ui_brewingArc;
    
    // Set title to "Brew"
    if (ui_BrewInfuseTitle != NULL) {
        lv_label_set_text(ui_BrewInfuseTitle, "Brew");
    }
    
    if (ui_BrewInfuseSetValue != NULL) {
        char temp_str[16];
        snprintf(temp_str, sizeof(temp_str), "%d °C", brewing_target_temp);
        lv_label_set_text(ui_BrewInfuseSetValue, temp_str);
    }
    
    // Reset arc to 0
    if (ui_brewingArc != NULL) {
        lv_arc_set_value(ui_brewingArc, 0);
    }
    
    // Request immediate temperature update
    uart_comm_get_temperature();
}

void onErrorScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_ERROR;
}

void onTeaPropertieScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_TEA_PROPERTIES;
    check_and_save_pending_nvs();
    update_tea_color();
    
    // Load tea parameters from NVS for current tea
    uint8_t temperature = settings_get_tea_temperature(current_tea_index);
    uint16_t infusion_time = settings_get_tea_infusion_time(current_tea_index);
    
    // Update temperature roller (75, 80, 85, 90, 95, 100)
    extern lv_obj_t * ui_Roller1;
    if (ui_Roller1) {
        uint16_t temp_index = (temperature - 75) / 5;
        if (temp_index > 5) temp_index = 5;
        lv_roller_set_selected(ui_Roller1, temp_index, LV_ANIM_OFF);
    }
    
    // Update infusion time rollers
    uint16_t minutes = infusion_time / 60;
    uint16_t seconds = infusion_time % 60;
    
    extern lv_obj_t * ui_Roller2;
    if (ui_Roller2) {
        if (minutes > 14) minutes = 14;
        lv_roller_set_selected(ui_Roller2, minutes, LV_ANIM_OFF);
    }
    
    extern lv_obj_t * ui_Roller4;
    if (ui_Roller4) {
        lv_roller_set_selected(ui_Roller4, seconds, LV_ANIM_OFF);
    }
}

void onBrewNowOrSchedulerScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_BREW_NOW_OR_SCHEDULER;
    check_and_save_pending_nvs();
}

void onSettingsScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_SETTINGS;
    check_and_save_pending_nvs();
    
    // Set color to Green Tea (index 0) for settings screen
    ui_theme_variable_t *color_ptr = (ui_theme_variable_t *)_ui_theme_color_teacolor;
    color_ptr[0] = tea_colors[0];
    _ui_theme_set_variable_styles(UI_VARIABLE_STYLES_MODE_FOLLOW);
    
    // Load drying time from NVS and update roller
    extern lv_obj_t * ui_Roller5;
    if (ui_Roller5) {
        uint8_t drying_time = settings_get_drying_time();
        lv_roller_set_selected(ui_Roller5, drying_time, LV_ANIM_OFF);
    }
}

void onSchedulerScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_SCHEDULER;
    check_and_save_pending_nvs();
}

void onScheduledScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_SCHEDULED;
}