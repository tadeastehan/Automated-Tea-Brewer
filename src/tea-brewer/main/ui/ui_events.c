// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.5.4
// LVGL version: 9.2.2
// Project name: SquareLine_Project

#include "ui.h"
#include "../settings.h"
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "freertos/timers.h"
#include "../uart_comm.h"
#include "esp_log.h"
#include "esp_lvgl_port.h"

static const char *TAG = "UI_EVENTS";

/* Set to 1 to show both object and ambient temperature, 0 for object only */
#define TEMPERATURE_DEBUG 0

// Define the screen state variable
ui_screen_state_t ui_screen_state = {0};

// Flags for pending NVS writes
static volatile bool position_save_pending = false;
static volatile bool tea_params_save_pending = false;

// Timer handles
static TimerHandle_t drying_position_save_timer = NULL;
static TimerHandle_t tea_params_save_timer = NULL;
static TimerHandle_t temperature_request_timer = NULL;

// NVS save task handle
static TaskHandle_t nvs_save_task_handle = NULL;

uint8_t current_tea_index = 0;  // Currently selected tea (0 = first tea)

/* Forward declarations */
static void temperature_request_timer_callback(TimerHandle_t xTimer);
static void on_temperature_update(float object_temp, float ambient_temp);

/* ============================================
   NVS SAVE TASK
   ============================================ */

// NVS save task - has enough stack for NVS operations
static void nvs_save_task(void *pvParameters)
{
    ESP_LOGI(TAG, "NVS save task started");
    
    while (1) {
        // Wait for notification (blocks until notified)
        ulTaskNotifyTake(pdTRUE, portMAX_DELAY);
        
        // Small delay to batch multiple rapid changes
        vTaskDelay(pdMS_TO_TICKS(100));
        
        // Save pending changes
        if (position_save_pending) {
            settings_flush_drying_position();
            position_save_pending = false;
            ESP_LOGI(TAG, "Drying position saved to NVS");
        }
        
        if (tea_params_save_pending) {
            settings_flush_tea_params();
            tea_params_save_pending = false;
            ESP_LOGI(TAG, "Tea params saved to NVS");
        }
    }
}

// Initialize NVS save task - call this from app_main
void ui_events_init(void)
{
    if (nvs_save_task_handle == NULL) {
        BaseType_t ret = xTaskCreate(
            nvs_save_task,
            "nvs_save",
            4096,  // 4KB stack - enough for NVS operations
            NULL,
            5,     // Low priority
            &nvs_save_task_handle
        );
        
        if (ret != pdPASS) {
            ESP_LOGE(TAG, "Failed to create NVS save task");
        }
    }
    
    /* Register temperature callback */
    uart_comm_set_temperature_callback(on_temperature_update);
    
    /* Create temperature request timer (5 second interval) */
    if (temperature_request_timer == NULL) {
        temperature_request_timer = xTimerCreate(
            "temp_timer",
            pdMS_TO_TICKS(5000),  // 5 seconds
            pdTRUE,               // Auto-reload
            NULL,
            temperature_request_timer_callback
        );
        
        if (temperature_request_timer != NULL) {
            xTimerStart(temperature_request_timer, 0);
            ESP_LOGI(TAG, "Temperature request timer started (5s interval)");
        } else {
            ESP_LOGE(TAG, "Failed to create temperature request timer");
        }
    }
}

/* ============================================
   TIMER CALLBACKS
   ============================================ */

// Timer callback - notify the NVS save task
static void drying_position_save_timer_callback(TimerHandle_t xTimer)
{
    position_save_pending = true;
    if (nvs_save_task_handle != NULL) {
        xTaskNotifyGive(nvs_save_task_handle);
    }
}

// Timer callback for tea params
static void tea_params_save_timer_callback(TimerHandle_t xTimer)
{
    tea_params_save_pending = true;
    if (nvs_save_task_handle != NULL) {
        xTaskNotifyGive(nvs_save_task_handle);
    }
}

// Timer callback for temperature requests (every 5 seconds)
static void temperature_request_timer_callback(TimerHandle_t xTimer)
{
    uart_comm_get_temperature();
}

// Temperature callback - update UI when temperature received
static void on_temperature_update(float object_temp, float ambient_temp)
{
    /* Update the temperature label on MainScreen */
    /* Must use LVGL port lock since this is called from UART task */
    extern lv_obj_t * ui_Temperature;
    if (ui_Temperature != NULL) {
        if (lvgl_port_lock(100)) {  /* 100ms timeout */
            char temp_str[32];
#if TEMPERATURE_DEBUG
            snprintf(temp_str, sizeof(temp_str), "%.1f °C\n%.1f °C", object_temp, ambient_temp);
#else
            snprintf(temp_str, sizeof(temp_str), "%.1f °C", object_temp);
#endif
            lv_label_set_text(ui_Temperature, temp_str);
            lvgl_port_unlock();
        }
    }
}

// Call this on screen changes (optional extra safety)
void check_and_save_pending_nvs(void)
{
    // If there are pending saves and task exists, trigger save
    if ((position_save_pending || tea_params_save_pending) && nvs_save_task_handle != NULL) {
        xTaskNotifyGive(nvs_save_task_handle);
    }
}

/* ============================================
   EVENT HANDLERS
   ============================================ */

void checkPot(lv_event_t * e)
{
    // Your code here
}

void stopBrewing(lv_event_t * e)
{
    // Your code here
}

void nextTeaScreen(lv_event_t * e)
{
    // Get the touch position from the event
    lv_point_t point;
    lv_indev_t * indev = lv_event_get_indev(e);
    if (indev) {
        lv_indev_get_point(indev, &point);
    } else {
        indev = lv_indev_active();
        if (indev) {
            lv_indev_get_point(indev, &point);
        } else {
            ESP_LOGW(TAG, "No input device found, defaulting to right side behavior");
            point.x = 320;  // Default to right side
        }
    }
    
    // Determine if touch is on left side (x <= 240) or right side (x > 240)
    bool is_left_side = (point.x <= 240);
    
    // Handle Main Screen
    if (ui_screen_state.current_screen == UI_SCREEN_MAIN) {
        if (is_left_side) {
            // Left side on main screen -> go to settings
            extern lv_obj_t * ui_SettingsScreen;
            if (ui_SettingsScreen) {
                _ui_screen_change(&ui_SettingsScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_SettingsScreen_screen_init);
            }
        } else {
            // Right side on main screen -> go to tea 0
            current_tea_index = 0;
            extern lv_obj_t * ui_TeaScreen;
            if (ui_TeaScreen) {
                _ui_screen_change(&ui_TeaScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_TeaScreen_screen_init);
            }
        }
        return;
    }
    
    // Handle Settings Screen
    if (ui_screen_state.current_screen == UI_SCREEN_SETTINGS) {
        if (is_left_side) {
            // Left side on settings screen -> go to last tea
            current_tea_index = MAX_TEA_TYPES - 1;
            extern lv_obj_t * ui_TeaScreen;
            if (ui_TeaScreen) {
                _ui_screen_change(&ui_TeaScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_TeaScreen_screen_init);
            }
        } else {
            // Right side on settings screen -> go to main screen
            extern lv_obj_t * ui_MainScreen;
            if (ui_MainScreen) {
                _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_MainScreen_screen_init);
            }
        }
        return;
    }
    
    // Handle Tea Screen navigation
    if (is_left_side) {
        // Left side - go to previous tea
        if (current_tea_index > 0) {
            current_tea_index--;
            update_tea_screen_label();
            update_tea_color();
            update_tea_background();
        } else {
            // If at first tea (index 0), go back to main screen
            extern lv_obj_t * ui_MainScreen;
            if (ui_MainScreen) {
                _ui_screen_change(&ui_MainScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_MainScreen_screen_init);
            }
        }
    } else {
        // Right side - go to next tea
        if (current_tea_index < MAX_TEA_TYPES - 1) {
            current_tea_index++;
            update_tea_screen_label();
            update_tea_color();
            update_tea_background();
        } else {
            // If at last tea, go to settings screen
            extern lv_obj_t * ui_SettingsScreen;
            if (ui_SettingsScreen) {
                _ui_screen_change(&ui_SettingsScreen, LV_SCR_LOAD_ANIM_NONE, 5, 0, &ui_SettingsScreen_screen_init);
            }
        }
    }
}

void changeScreenToTeaPropertiesScreen(lv_event_t * e)
{
    // Your code here
}

void changeTeaTemperature(lv_event_t * e)
{
    // Your code here
}

void changeInfusionTimeSecond(lv_event_t * e)
{
    lv_obj_t * roller = lv_event_get_target(e);
    if (roller) {
        uint16_t selected_seconds = lv_roller_get_selected(roller);
        
        // Get current infusion time and update only seconds
        uint16_t current_time = settings_get_tea_infusion_time(current_tea_index);
        uint16_t minutes = current_time / 60;
        uint16_t new_time = (minutes * 60) + selected_seconds;
        
        settings_set_tea_infusion_time_no_save(current_tea_index, new_time);
        
        // Create or reset timer
        if (tea_params_save_timer == NULL) {
            tea_params_save_timer = xTimerCreate(
                "TeaParamsSave",
                pdMS_TO_TICKS(10000),
                pdFALSE,
                0,
                tea_params_save_timer_callback
            );
        }
        
        if (tea_params_save_timer != NULL) {
            xTimerReset(tea_params_save_timer, 0);
        }
    }
}

void changeInfusionTimeMinute(lv_event_t * e)
{
    lv_obj_t * roller = lv_event_get_target(e);
    if (roller) {
        uint16_t selected_minutes = lv_roller_get_selected(roller);
        
        // Get current infusion time and update only minutes
        uint16_t current_time = settings_get_tea_infusion_time(current_tea_index);
        uint16_t seconds = current_time % 60;
        uint16_t new_time = (selected_minutes * 60) + seconds;
        
        settings_set_tea_infusion_time_no_save(current_tea_index, new_time);
        
        // Create or reset timer
        if (tea_params_save_timer == NULL) {
            tea_params_save_timer = xTimerCreate(
                "TeaParamsSave",
                pdMS_TO_TICKS(10000),
                pdFALSE,
                0,
                tea_params_save_timer_callback
            );
        }
        
        if (tea_params_save_timer != NULL) {
            xTimerReset(tea_params_save_timer, 0);
        }
    }
}

void ReturnToTeaScreen(lv_event_t * e)
{
    // Your code here
}

void brewNow(lv_event_t * e)
{
    // Your code here
}

void startBrewing(lv_event_t * e)
{
    // Your code here
}

void changeBrewingTeaTemperature(lv_event_t * e)
{
    lv_obj_t * roller = lv_event_get_target(e);
    if (roller) {
        uint16_t selected = lv_roller_get_selected(roller);
        // Temperature options: 75, 80, 85, 90, 95, 100
        uint8_t temperature = 75 + (selected * 5);
        settings_set_tea_temperature_no_save(current_tea_index, temperature);
        
        // Create or reset timer for delayed NVS write (10 seconds)
        if (tea_params_save_timer == NULL) {
            tea_params_save_timer = xTimerCreate(
                "TeaParamsSave",
                pdMS_TO_TICKS(10000),
                pdFALSE,
                0,
                tea_params_save_timer_callback
            );
        }
        
        if (tea_params_save_timer != NULL) {
            xTimerReset(tea_params_save_timer, 0);
        }
    }
}

void changeDryingTime(lv_event_t * e)
{
    lv_obj_t * roller = lv_event_get_target(e);
    if (roller) {
        uint16_t selected = lv_roller_get_selected(roller);
        settings_set_drying_time((uint8_t)selected);
    }
}

void dryingPositionUp(lv_event_t * e)
{
    int current_position = settings_get_drying_position();
    
    // Limit to 0-100 range
    if (current_position >= 100) {
        ESP_LOGW(TAG, "Drying position already at maximum (100%%)");
        return;
    }
    
    current_position++;
    settings_set_drying_position_no_save(current_position);
    
    // Move motor to new position
    ui_motor_move_to_drying_position(current_position);
    
    ESP_LOGI(TAG, "Drying position UP: %d%%", current_position);
    
    // Create or reset timer for delayed NVS write (10 seconds)
    if (drying_position_save_timer == NULL) {
        drying_position_save_timer = xTimerCreate(
            "DryingPosSave",
            pdMS_TO_TICKS(10000),
            pdFALSE,
            0,
            drying_position_save_timer_callback
        );
    }
    
    if (drying_position_save_timer != NULL) {
        xTimerReset(drying_position_save_timer, 0);
    }
}

void dryingPositionDown(lv_event_t * e)
{
    int current_position = settings_get_drying_position();
    
    // Limit to 0-100 range
    if (current_position <= 0) {
        ESP_LOGW(TAG, "Drying position already at minimum (0%%)");
        return;
    }
    
    current_position--;
    settings_set_drying_position_no_save(current_position);
    
    // Move motor to new position
    ui_motor_move_to_drying_position(current_position);
    
    ESP_LOGI(TAG, "Drying position DOWN: %d%%", current_position);
    
    // Create or reset timer for delayed NVS write (10 seconds)
    if (drying_position_save_timer == NULL) {
        drying_position_save_timer = xTimerCreate(
            "DryingPosSave",
            pdMS_TO_TICKS(10000),
            pdFALSE,
            0,
            drying_position_save_timer_callback
        );
    }
    
    if (drying_position_save_timer != NULL) {
        xTimerReset(drying_position_save_timer, 0);
    }
}

void changeSchedulerTemperature(lv_event_t * e)
{
    // Your code here
}

void changeSchedulerTimeMinute(lv_event_t * e)
{
    // Your code here
}

void changeSchedulerTimeHour(lv_event_t * e)
{
    // Your code here
}

void beginScheduler(lv_event_t * e)
{
    // Your code here
}

void stopScheduledBrew(lv_event_t * e)
{
    // Your code here
}

void onMainScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_MAIN;
    check_and_save_pending_nvs();
}

void onTeaScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_TEA;
    check_and_save_pending_nvs();
    update_tea_screen_label();
    update_tea_color();
    update_tea_background();
}

void onTeapotScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_TEAPOT;
    check_and_save_pending_nvs();
}

void onBrewInfuseScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_BREW_INFUSE;
    check_and_save_pending_nvs();
}

void onErrorScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_ERROR;
}

void onTeaPropertieScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_TEA_PROPERTIES;
    check_and_save_pending_nvs();
    update_tea_color();
    
    // Load tea parameters from NVS for current tea
    uint8_t temperature = settings_get_tea_temperature(current_tea_index);
    uint16_t infusion_time = settings_get_tea_infusion_time(current_tea_index);
    
    // Update temperature roller (75, 80, 85, 90, 95, 100)
    extern lv_obj_t * ui_Roller1;
    if (ui_Roller1) {
        uint16_t temp_index = (temperature - 75) / 5;
        if (temp_index > 5) temp_index = 5;
        lv_roller_set_selected(ui_Roller1, temp_index, LV_ANIM_OFF);
    }
    
    // Update infusion time rollers
    uint16_t minutes = infusion_time / 60;
    uint16_t seconds = infusion_time % 60;
    
    extern lv_obj_t * ui_Roller2;
    if (ui_Roller2) {
        if (minutes > 14) minutes = 14;
        lv_roller_set_selected(ui_Roller2, minutes, LV_ANIM_OFF);
    }
    
    extern lv_obj_t * ui_Roller4;
    if (ui_Roller4) {
        lv_roller_set_selected(ui_Roller4, seconds, LV_ANIM_OFF);
    }
}

void onBrewNowOrSchedulerScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_BREW_NOW_OR_SCHEDULER;
    check_and_save_pending_nvs();
}

void onSettingsScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_SETTINGS;
    check_and_save_pending_nvs();
    
    // Set color to Green Tea (index 0) for settings screen
    ui_theme_variable_t *color_ptr = (ui_theme_variable_t *)_ui_theme_color_teacolor;
    color_ptr[0] = tea_colors[0];
    _ui_theme_set_variable_styles(UI_VARIABLE_STYLES_MODE_FOLLOW);
    
    // Load drying time from NVS and update roller
    extern lv_obj_t * ui_Roller5;
    if (ui_Roller5) {
        uint8_t drying_time = settings_get_drying_time();
        lv_roller_set_selected(ui_Roller5, drying_time, LV_ANIM_OFF);
    }
}

void onSchedulerScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_SCHEDULER;
    check_and_save_pending_nvs();
}

void onScheduledScreen(lv_event_t * e)
{
    ui_screen_state.current_screen = UI_SCREEN_SCHEDULED;
}